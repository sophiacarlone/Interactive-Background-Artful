#version 450

// There's no `location` for `in`; it's just used to specify the local workgroup dimensions.
// @todo local workgroup size chosen arbitrarily; choose it properly (maybe programmatically determine on host
// and pass in via... a specialization constant or something?)
layout(local_size_x = 32) in;

struct Boid {
    vec2 pos;
    vec2 vel;
};

// the boids buffer
layout(binding = 0, std140) buffer Boids {
    // The array size is just the allocation, not the number of boids.
    // @todo since this is a storage buffer, we can make the array size larger or maybe even not specify it
    Boid boids[1024];
};
layout(push_constant, std140) uniform PushConsts {
    vec2 ATTRACTOR_POS;
    uint N_BOIDS;
};

// helpers to avoid branching. Never actually benchmarked to see if this was better
vec2 whenLessThan(   vec2 a, vec2 b) { return max(sign(b - a), 0.0); }
vec2 whenGreaterThan(vec2 a, vec2 b) { return max(sign(a - b), 0.0); }

const float COLLISION_AVOIDANCE_RADIUS = 0.1; // @todo make the radius scale with speed?
const float SPEED_CAP = 1.0;
const float DT = 0.01; // time step
// weight factors; modify to increase or decrease priority of different factors
const float WEIGHT_SEPARATION = 0.02;
const float WEIGHT_COHESION   = 0.50;
const float WEIGHT_ALIGNMENT  = 1.00;
const float WEIGHT_ATTRACTION = 1.00;
//
void main() {
    uint boidInd = gl_GlobalInvocationID.x;
    // if you don't have a boid to update, return immediately
    if (boidInd >= N_BOIDS) return;
    Boid boid = boids[boidInd];

    float reciprocalNOtherBoids = 1.0 / float(N_BOIDS - 1);

    // Compute sums of boid positions and velocities.
    // These will be used later to compute means.
    vec2 sumPos = vec2(0.0);
    vec2 sumVel = vec2(0.0);
    // @todo @optimize This is a stupid placeholder computation method. Use parallel reduction for this.
    // @optimize Stuff like this would probably be more efficient if pos and vel were together in a vec4.
    for (int i = 0; i < N_BOIDS; ++i) {
        sumPos += boids[i].pos;
        sumVel += boids[i].vel;
    }

    // Compute acceleration due to cohesion
    // @optimize maybe we can get this to become an `fma`
    vec2 meanPos = (sumPos - boid.pos) * reciprocalNOtherBoids; // mean pos of all other boids
    vec2 accCohesion = meanPos - boid.pos;

    // Compute acceleration due to alignment
    // @optimize maybe we can get this to become an `fma`
    vec2 meanVel = (sumVel - boid.vel) * reciprocalNOtherBoids; // mean vel of all other boids
    vec2 accAlignment = meanVel - boid.vel;

    // Compute acceleration due to separation
    vec2 accSeparation = vec2(0.0);
    for (int i = 0; i < N_BOIDS; ++i) {
        Boid otherBoid = boids[i];

        vec2 disp = boid.pos - otherBoid.pos;
        float dist = length(disp);
        // Accelerate away from the other boid (with acc proportional to 1/dist) iff all of:
        //     1. it's too close to us
        //     2. it isn't us
        //     3. its distance from us isn't 0 (to avoid division by 0)
        accSeparation += mix(
            vec2(0.0),
            disp / (dist * dist),
            bvec2(dist < COLLISION_AVOIDANCE_RADIUS && i != boidInd && dist != 0.0)
        );
    }

    // Compute acceleration due to attraction to an object (e.g. the object is bread and the birds want it)
    vec2 attractorDisp = ATTRACTOR_POS - boid.pos;
    // @todo Not sure why I decided to normalize, but it looks cool and reduces the magnitude of overshooting.
    // Avoid normalizing the 0 vector, which isn't defined in the GLSL spec.
    // @optimize idk how to get rid of the potential branching here
    vec2 accAttraction = attractorDisp == vec2(0.0) ? vec2(0.0) : normalize(attractorDisp);

    // Compute new boid values due to net acceleration
    Boid newBoid;
    vec2 netAcc =
        WEIGHT_COHESION   * accCohesion   + 
        WEIGHT_SEPARATION * accSeparation + 
        WEIGHT_ALIGNMENT  * accAlignment  +
        WEIGHT_ATTRACTION * accAttraction;
    // @optimize under what conditions is this compiled to an `fma` instruction?
    newBoid.vel = boid.vel + DT*netAcc;
    // @todo what does `normalize` do when its input is has length 0?
    newBoid.vel = normalize(newBoid.vel) * min(length(newBoid.vel), SPEED_CAP); // enforce speed limit
    newBoid.pos = boid.pos + DT*newBoid.vel;
    // Wrap around if crossing window border. // @todo disable this behavior
    newBoid.pos +=
         2.0 * whenLessThan(   newBoid.pos, vec2(-1.0))
        -2.0 * whenGreaterThan(newBoid.pos, vec2( 1.0));

    // Since the boid computations depend on the positions and velocities of other boids, we should wait for
    // every invocation to finish computing their boids before we modify the boids buffer.
    // @optimize could we put this barrier earlier? We just need to be past the last point where the shader
    // fetches data from the boids buffer.
    barrier();
    // Finally, update the boids buffer with the new values.
    boids[boidInd] = newBoid;
}